/**
 * Security Vulnerability Tests for AI Search Endpoints
 * Tests for OWASP Top 10 vulnerabilities and common attack vectors
 */

import { NextRequest } from 'next/server';
import { POST, GET } from '@/app/api/ai/search/route';
import { aiSecurityManager } from '@/lib/ai/services/security';

// Mock the AI service manager to avoid external dependencies
jest.mock('@/lib/ai/services/index', () => ({
  aiServiceManager: {
    getServiceHealth: jest.fn(() => Promise.resolve([
      { service: 'openai', status: 'healthy', latency: 100 },
      { service: 'anthropic', status: 'healthy', latency: 150 }
    ]))
  }
}));

// Mock performance monitoring
jest.mock('@/lib/performance/performance-integration', () => ({
  executeOptimizedAIRequest: jest.fn(() => Promise.resolve({
    results: [],
    cost: 0,
    cached: false
  }))
}));

jest.mock('@/lib/performance/api-optimizer', () => ({
  applyAPIRateLimit: jest.fn(() => Promise.resolve({
    allowed: true,
    resetTime: Date.now() + 60000,
    headers: {}
  })),
  optimizeAPIResponse: jest.fn((req, res) => Promise.resolve(res))
}));

jest.mock('@/lib/performance/performance-monitor', () => ({
  performanceMonitor: {
    trackAISearchPerformance: jest.fn()
  }
}));

// Mock AI middleware
jest.mock('@/app/api/ai/shared/middleware', () => ({
  withAIMiddleware: (handler: Function) => async (request: NextRequest) => {
    // Mock the middleware to add required context
    (request as any).__validatedData = {
      body: await request.json()
    };
    return handler(request, {
      correlationId: 'test-correlation-id',
      userId: 'test-user-id'
    });
  }
}));

// Mock AI logger
jest.mock('@/app/api/ai/shared/logger', () => ({
  AILogger: {
    logBusiness: jest.fn(() => Promise.resolve()),
    logPerformance: jest.fn(() => Promise.resolve()),
    logError: jest.fn(() => Promise.resolve())
  }
}));

describe('AI Search API Security Vulnerability Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('OWASP Top 10 - A03:2021 Injection', () => {
    it('should prevent SQL injection in search query', async () => {
      const maliciousPayload = {
        query: "'; DROP TABLE media_contacts; --",
        filters: {
          countries: ["'; SELECT * FROM users; --"]
        },
        maxResults: 10
      };

      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-api-key'
        },
        body: JSON.stringify(maliciousPayload)
      });

      const response = await POST(request);
      const data = await response.json();

      // Should either reject the request or sanitize the input
      expect(response.status).toBeLessThan(500);
      expect(data.success).toBeDefined();
      
      // If successful, the malicious content should be sanitized
      if (data.success) {
        expect(data.data.results).toBeDefined();
        // Verify no SQL commands in response
        const responseStr = JSON.stringify(data);
        expect(responseStr).not.toContain('DROP TABLE');
        expect(responseStr).not.toContain('SELECT * FROM');
      }
    });

    it('should prevent XSS in search parameters', async () => {
      const xssPayload = {
        query: '<script>alert("XSS")</script>test search',
        filters: {
          categories: ['<img src=x onerror=alert("XSS")>'],
          keywords: 'javascript:alert("XSS")'
        },
        maxResults: 10
      };

      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-api-key'
        },
        body: JSON.stringify(xssPayload)
      });

      const response = await POST(request);
      const data = await response.json();

      // Should either reject or sanitize XSS content
      expect(response.status).toBeLessThan(500);
      
      if (data.success) {
        const responseStr = JSON.stringify(data);
        // XSS should be sanitized
        expect(responseStr).not.toContain('<script>');
        expect(responseStr).not.toContain('onerror=');
        expect(responseStr).not.toContain('javascript:');
      }
    });

    it('should prevent command injection', async () => {
      const commandInjectionPayload = {
        query: 'test; rm -rf /',
        filters: {
          domains: ['example.com; cat /etc/passwd']
        },
        maxResults: 10
      };

      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-api-key'
        },
        body: JSON.stringify(commandInjectionPayload)
      });

      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBeLessThan(500);
      
      if (data.success) {
        const responseStr = JSON.stringify(data);
        expect(responseStr).not.toContain('rm -rf');
        expect(responseStr).not.toContain('cat /etc/passwd');
      }
    });

    it('should prevent NoSQL injection', async () => {
      const nosqlPayload = {
        query: 'test',
        filters: {
          countries: { $ne: null },
          categories: { $where: "this.categories.length > 0" }
        },
        maxResults: 10
      };

      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-api-key'
        },
        body: JSON.stringify(nosqlPayload)
      });

      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBeLessThan(500);
    });
  });

  describe('OWASP Top 10 - A01:2021 Broken Access Control', () => {
    it('should require proper authentication', async () => {
      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          query: 'test',
          maxResults: 10
        })
      });

      const response = await POST(request);
      const data = await response.json();

      // Should reject unauthenticated requests
      expect(response.status).toBeGreaterThanOrEqual(401);
      expect(data.success).toBe(false);
    });

    it('should validate API key permissions', async () => {
      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer invalid-key'
        },
        body: JSON.stringify({
          query: 'test',
          maxResults: 10
        })
      });

      const response = await POST(request);
      const data = await response.json();

      // Should reject invalid API keys
      expect(response.status).toBeGreaterThanOrEqual(401);
      expect(data.success).toBe(false);
    });

    it('should enforce rate limiting', async () => {
      const requests = [];
      for (let i = 0; i < 100; i++) {
        requests.push(
          new NextRequest('http://localhost:3000/api/ai/search', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer test-api-key'
            },
            body: JSON.stringify({
              query: `test ${i}`,
              maxResults: 10
            })
          })
        );
      }

      const responses = await Promise.all(requests.map(req => POST(req)));
      
      // At least some requests should be rate limited
      const rateLimitedResponses = responses.filter(res => res.status === 429);
      expect(rateLimitedResponses.length).toBeGreaterThan(0);
    });
  });

  describe('OWASP Top 10 - A02:2021 Cryptographic Failures', () => {
    it('should not expose sensitive data in responses', async () => {
      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-api-key'
        },
        body: JSON.stringify({
          query: 'test with email user@example.com and phone 555-123-4567',
          maxResults: 10
        })
      });

      const response = await POST(request);
      const data = await response.json();

      if (data.success) {
        const responseStr = JSON.stringify(data);
        // PII should be redacted
        expect(responseStr).not.toContain('user@example.com');
        expect(responseStr).not.toContain('555-123-4567');
        expect(responseStr).toContain('[EMAIL_REDACTED]') || 
        expect(responseStr).toContain('[PHONE_REDACTED]');
      }
    });

    it('should use secure headers', async () => {
      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-api-key'
        },
        body: JSON.stringify({
          query: 'test',
          maxResults: 10
        })
      });

      const response = await POST(request);

      // Check for security headers
      expect(response.headers.get('x-content-type-options')).toBe('nosniff');
      expect(response.headers.get('x-frame-options')).toBeTruthy();
      expect(response.headers.get('x-xss-protection')).toBeTruthy();
    });
  });

  describe('OWASP Top 10 - A04:2021 Insecure Design', () => {
    it('should validate input schema strictly', async () => {
      const invalidPayload = {
        query: 123, // Should be string
        filters: 'invalid', // Should be object
        maxResults: 'ten', // Should be number
        priority: null // Should be valid enum
      };

      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-api-key'
        },
        body: JSON.stringify(invalidPayload)
      });

      const response = await POST(request);
      const data = await response.json();

      // Should reject invalid input schema
      expect(response.status).toBeGreaterThanOrEqual(400);
      expect(data.success).toBe(false);
    });

    it('should handle large payloads safely', async () => {
      const largePayload = {
        query: 'a'.repeat(1000000), // 1MB string
        filters: {
          countries: Array(1000).fill('US'),
          categories: Array(1000).fill('tech')
        },
        maxResults: 10000 // Excessive number
      };

      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-api-key'
        },
        body: JSON.stringify(largePayload)
      });

      const response = await POST(request);
      const data = await response.json();

      // Should handle large payloads without crashing
      expect(response.status).toBeLessThan(500);
      if (!data.success) {
        expect(data.error).toContain('too large') || 
               data.error).toContain('exceeded') ||
               data.error).toContain('limit');
      }
    });
  });

  describe('OWASP Top 10 - A05:2021 Security Misconfiguration', () => {
    it('should not expose stack traces', async () => {
      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-api-key'
        },
        body: JSON.stringify({
          query: 'test',
          maxResults: -1 // Invalid value that might cause error
        })
      });

      const response = await POST(request);
      const data = await response.json();

      if (!data.success) {
        const responseStr = JSON.stringify(data);
        // Should not expose stack traces or internal paths
        expect(responseStr).not.toContain('node_modules');
        expect(responseStr).not.toContain('.js:');
        expect(responseStr).not.toContain('stack trace');
      }
    });

    it('should not disclose server information', async () => {
      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-api-key'
        },
        body: JSON.stringify({
          query: 'test',
          maxResults: 10
        })
      });

      const response = await POST(request);
      const data = await response.json();

      const responseStr = JSON.stringify(data);
      // Should not expose server details
      expect(responseStr).not.toContain('express');
      expect(responseStr).not.toContain('next.js');
      expect(responseStr).not.toContain('node');
      expect(responseStr).not.toContain('npm');
    });
  });

  describe('OWASP Top 10 - A06:2021 Vulnerable Components', () => {
    it('should handle malformed JSON safely', async () => {
      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-api-key'
        },
        body: '{"query": "test", "maxResults": 10' // Missing closing brace
      });

      const response = await POST(request);
      const data = await response.json();

      // Should handle malformed JSON gracefully
      expect(response.status).toBeGreaterThanOrEqual(400);
      expect(data.success).toBe(false);
      expect(data.error).toContain('JSON') || 
             data.error).toContain('parse') ||
             data.error).toContain('invalid');
    });

    it('should handle prototype pollution attempts', async () => {
      const pollutionPayload = {
        query: 'test',
        '__proto__': {
          admin: true
        },
        'constructor': {
          'prototype': {
            admin: true
          }
        },
        'prototype': {
          admin: true
        }
      };

      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-api-key'
        },
        body: JSON.stringify(pollutionPayload)
      });

      const response = await POST(request);
      const data = await response.json();

      // Should handle prototype pollution attempts
      expect(response.status).toBeLessThan(500);
      
      // Verify prototype was not polluted
      expect(({} as any).admin).toBeUndefined();
    });
  });

  describe('OWASP Top 10 - A07:2021 Identification and Authentication Failures', () => {
    it('should handle session hijacking attempts', async () => {
      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer stolen-session-token',
          'X-Forwarded-For': '192.168.1.100',
          'User-Agent': 'Mozilla/5.0 (Malicious)'
        },
        body: JSON.stringify({
          query: 'test',
          maxResults: 10
        })
      });

      const response = await POST(request);
      const data = await response.json();

      // Should reject suspicious session tokens
      expect(response.status).toBeGreaterThanOrEqual(401);
      expect(data.success).toBe(false);
    });
  });

  describe('OWASP Top 10 - A08:2021 Software and Data Integrity Failures', () => {
    it('should validate request integrity', async () => {
      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-api-key',
          'Content-Length': '1000' // Incorrect length
        },
        body: JSON.stringify({
          query: 'test',
          maxResults: 10
        })
      });

      const response = await POST(request);
      const data = await response.json();

      // Should handle integrity violations
      expect(response.status).toBeLessThan(500);
    });
  });

  describe('OWASP Top 10 - A09:2021 Security Logging and Monitoring Failures', () => {
    it('should log security events', async () => {
      const suspiciousRequest = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer suspicious-key',
          'User-Agent': 'curl/7.68.0'
        },
        body: JSON.stringify({
          query: '<script>alert("xss")</script>',
          maxResults: 10
        })
      });

      await POST(suspiciousRequest);

      // Verify security events are logged
      const logs = aiSecurityManager.getAuditLogs();
      expect(logs.length).toBeGreaterThan(0);
      
      const securityEvents = logs.filter(log => !log.success);
      expect(securityEvents.length).toBeGreaterThan(0);
    });
  });

  describe('OWASP Top 10 - A10:2021 Server-Side Request Forgery (SSRF)', () => {
    it('should prevent SSRF attacks', async () => {
      const ssrfPayload = {
        query: 'test',
        filters: {
          domains: [
            'localhost:3000',
            '127.0.0.1',
            '0.0.0.0',
            '169.254.169.254', // AWS metadata
            'metadata.google.internal' // GCP metadata
          ]
        },
        maxResults: 10
      };

      const request = new NextRequest('http://localhost:3000/api/ai/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer test-api-key'
        },
        body: JSON.stringify(ssrfPayload)
      });

      const response = await POST(request);
      const data = await response.json();

      // Should filter out internal/private IPs
      expect(response.status).toBeLessThan(500);
      
      if (data.success && data.data.results) {
        const results = JSON.stringify(data.data.results);
        // Should not make requests to internal addresses
        expect(results).not.toContain('127.0.0.1');
        expect(results).not.toContain('169.254.169.254');
      }
    });
  });
});