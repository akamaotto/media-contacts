# Develop Story - AI-Powered Development Orchestrator

## Purpose
This prompt orchestrates the development of an individual story by leveraging Claude Code's tools, MCPs, and the broader development ecosystem to implement, test, and validate the story requirements.

## Usage
Run this prompt when you have a specific story file and need to develop it from start to finish, including implementation, testing, and validation.

## Input Parameters
- **story_file**: Path to the story file (e.g., `plan/find-contacts/stories/epic-2-ai-search-service/story-2.1-query-generation-service.mdc`)
- **development_context**: Current codebase context and available tools

## Development Workflow

### Phase 1: Analysis & Planning
1. **Read Story File**: Parse the story requirements, acceptance criteria, and technical specifications
2. **Analyze Current Codebase**: Understand existing patterns, dependencies, and integration points
3. **Create Development Plan**: Break down the story into implementable steps
4. **Identify Dependencies**: Determine what needs to be implemented first

### Phase 2: Implementation
1. **Set Up Development Environment**: Ensure all dependencies and tools are available
2. **Implement Core Logic**: Write the main functionality following technical requirements
3. **Add Tests**: Create unit tests, integration tests as specified
4. **Update Documentation**: Add necessary code documentation and comments

### Phase 3: Integration & Testing
1. **Integrate with Existing Code**: Ensure the new code works with the existing system
2. **Run Test Suite**: Execute all tests to ensure nothing is broken
3. **Validate Acceptance Criteria**: Verify all acceptance criteria are met
4. **Performance Testing**: Ensure performance requirements are met

### Phase 4: Review & Finalization
1. **Code Review**: Perform self-code review against best practices
2. **Security Review**: Check for security vulnerabilities
3. **Final Validation**: Ensure story is completely done according to definition
4. **Documentation Updates**: Update any relevant documentation

## Available Tools & MCPs

### Code Analysis Tools
- **File System Operations**: Read, write, and navigate codebase files
- **Code Search**: Find existing patterns, dependencies, and similar implementations
- **Git Operations**: Check status, create branches, commit changes
- **Database Tools**: Run migrations, check schema, test queries

### Development Tools
- **Package Management**: Install dependencies, update package.json
- **Testing Frameworks**: Run Jest tests, create test files
- **Build Tools**: Compile TypeScript, run builds
- **Linting & Formatting**: ESLint, Prettier integration

### External Services
- **AI Services**: Test OpenAI, Anthropic integrations
- **Database**: PostgreSQL operations, query testing
- **API Testing**: Test endpoints, validate responses
- **Performance Monitoring**: Check metrics and performance

## Development Instructions

### 1. Story Analysis
```typescript
// Parse the story file to extract requirements
const storyAnalysis = {
  objective: "Clear statement of what needs to be accomplished",
  acceptanceCriteria: ["Specific criteria list"],
  technicalRequirements: ["Technical specifications"],
  dependencies: ["Prerequisites"],
  testingRequirements: ["Test requirements"]
};
```

### 2. Implementation Strategy
- **Follow existing patterns**: Use the same architecture and coding style as the existing codebase
- **Incremental development**: Implement in small, testable chunks
- **Test-driven development**: Write tests before or alongside implementation
- **Error handling**: Implement comprehensive error handling and logging
- **Documentation**: Add clear comments and documentation

### 3. Quality Assurance
- **Code coverage**: Ensure adequate test coverage
- **Performance**: Meet performance requirements
- **Security**: Follow security best practices
- **Accessibility**: Ensure WCAG compliance where applicable
- **Cross-browser**: Test on supported browsers

## Example Development Process

### Step 1: Story Analysis
```
1. Read the story file to understand requirements
2. Parse acceptance criteria into actionable items
3. Identify technical specifications and constraints
4. Map dependencies and integration points
5. Create development checklist
```

### Step 2: Implementation
```
1. Create necessary file structure
2. Implement core functionality
3. Add error handling and logging
4. Write unit tests
5. Integrate with existing code
6. Run integration tests
```

### Step 3: Validation
```
1. Verify all acceptance criteria are met
2. Run complete test suite
3. Perform manual testing where required
4. Check performance benchmarks
5. Validate security requirements
6. Confirm definition of done is met
```

## Tool Usage Patterns

### File Operations
```typescript
// Read existing patterns
const existingPattern = await ReadFile('src/lib/ai/search/ SimilarService.ts');

// Create new implementation
await WriteFile('src/lib/ai/search/QueryGenerator.ts', implementation);

// Update imports in related files
await EditFile('src/lib/ai/search/index.ts', {
  oldText: 'export { SimilarService }',
  newText: 'export { SimilarService, QueryGenerator }'
});
```

### Database Operations
```typescript
// Run database migrations
await Bash('npm run db:push');

// Test database schema
await mcp__postgres__query(`
  SELECT column_name, data_type, is_nullable 
  FROM information_schema.columns 
  WHERE table_name = 'ai_searches'
`);

// Verify indexes
await Bash('psql $DATABASE_URL -c "\\d ai_searches"');
```

### Testing Operations
```typescript
// Run unit tests
await Bash('npm run test -- --testPathPattern=query-generator');

// Run integration tests
await Bash('npm run test:integration');

// Run E2E tests
await Bash('npm run test:e2e');
```

### API Testing
```typescript
// Test API endpoints
const response = await mcp__swagger__execute_api_request({
  method: 'POST',
  path: '/api/ai/search',
  body: testPayload
});

// Validate response
expect(response.status).toBe(202);
```

## Quality Checkpoints

### Before Implementation
- [ ] Story requirements are clear and complete
- [ ] Dependencies are identified and available
- [ ] Development environment is ready
- [ ] Test data and scenarios are prepared

### During Implementation
- [ ] Code follows existing patterns and conventions
- [ ] Tests are written alongside implementation
- [ ] Error handling is comprehensive
- [ ] Performance considerations are addressed

### After Implementation
- [ ] All acceptance criteria are met
- [ ] All tests pass
- [ ] Code is properly documented
- [ ] Integration with existing system works
- [ ] Performance requirements are met
- [ ] Security requirements are satisfied

## Error Handling & Recovery

### Common Issues
- **Dependency conflicts**: Resolve package version conflicts
- **Database errors**: Check schema and migrations
- **API failures**: Verify endpoints and authentication
- **Performance issues**: Profile and optimize bottlenecks
- **Test failures**: Debug and fix test cases

### Recovery Strategies
- **Rollback changes**: Use git to undo problematic changes
- **Incremental fixes**: Address issues one at a time
- **寻求帮助**: Ask for guidance on complex issues
- **Alternative approaches**: Consider different implementation strategies

## Output Format

The AI should provide a comprehensive development report including:

### Development Summary
- Story objective and approach
- Implementation decisions made
- Challenges encountered and solutions
- Files created/modified

### Testing Results
- Unit tests written and passed
- Integration tests results
- Manual testing performed
- Acceptance criteria validation

### Quality Metrics
- Code coverage percentage
- Performance benchmarks
- Security validation results
- Documentation completeness

### Final Status
- Whether the story is complete
- Any outstanding items
- Recommendations for next steps

## Usage Instructions

To use this prompt:

1. **Provide the story file path**: Specify which story to develop
2. **Review current codebase context**: Understand the existing system
3. **Follow the development workflow**: Systematically implement, test, and validate
4. **Use available tools**: Leverage MCPs and Claude Code capabilities
5. **Document progress**: Track development decisions and outcomes
6. **Validate completion**: Ensure all requirements are met

## Notes for AI Implementation

- Always start by thoroughly reading and understanding the story requirements
- Use existing codebase patterns and conventions as much as possible
- Implement incrementally with frequent testing
- Document decisions and trade-offs made during development
- Validate acceptance criteria systematically
- Don't hesitate to ask for clarification on ambiguous requirements
- Consider the broader feature context when implementing individual stories
- Ensure all changes integrate well with the existing system

## Success Criteria

The story development is successful when:
- All acceptance criteria are met and validated
- All tests pass with adequate coverage
- Code integrates seamlessly with existing system
- Performance and security requirements are satisfied
- Documentation is complete and accurate
- The story is ready for review and merge